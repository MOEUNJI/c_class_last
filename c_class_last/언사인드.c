#include <stdio.h>
int main(void)
{
	unsigned char ch; // 값의 범위 : 0 ~ 255 (원래는 -128 ~ 127)
	unsigned short sh; //값의 범위 : 0 ~ 65,535 ( 원래는 -32,768 ~ 32,767)
	unsigned int in; // 값의 범위 : 0 ~ 4,294,967,295 ( - 21억 ~ 21억 )

	// 사인드 값의 범위는 작지만 지금 언사인드로 변환한 상태라 값이 들어갈 것이다.
	ch = 128; // 디폴트 값인 사인드char 형의 최대값은 127이다.
	sh = 50000; // 사인드 값의 범위는 32,767이다.
	in = 4100000000; // ( - 21억 ~ 21억 )
	printf("%d\n", ch);
	printf("%d\n", sh);
	printf("%u\n", in);
	// int만 %u 로 바꾸는 이유
	// unsigned char와 unsigned short는 int 범위 내에 있기 때문에
	// %d 는 int 값의 범위 내에서만 올바르게 출력이 가능하다.
	// 즉 int값의 범위를 넘어가면 바꿔주어야 겠죠?

	char num = 255;
	printf("%d", num); // -1이 나온다
	// 01111111(127)이 사인드 char가 가질 수 있는 값의 범위인데 255는 초과하고 있기 때문이다.
	// -1이 나오는 이유는 255를 2진법으로 바꿔보게 되면 11111111이라는 수가 나온다.
	// 255 / 2 = 127 ... 1
	// 127 ÷ 2 = 63 … 1
	// 63 ÷ 2 = 31 … 1
	// 31 ÷ 2 = 15 … 1
	// 5 ÷ 2 = 7 … 1
	// 7 ÷ 2 = 3 … 1
	// 3 ÷ 2 = 1 … 1
	// 1 ÷ 2 = 0 … 1 
	// 나머지를 아래서부터 역순으로 읽으면 11111111이 된다.
	// 그런데 지금 11111111을 보면 제일 왼쪽 부호비트 부분이 1이므로 음수로 나타난다.
	// 양수인 255가 아니라는 소리이다.
	// 음수인 첫번째 부호비트를 빼고 나머지 7비트를 2의 보수로 해석해보면
	// 00000000 으로 모든 비트를 뒤집고 +1을 하면  00000001로 바뀐다.
	// 여기에 마이너스 부호비트 맨 앞에 붙여주게 되면 10000001이 된다 즉 -1이 되는 것!
	// 따라서 255는 강제로 2의 보수로 음수로 변환되어
	// 11111111은 강제로 값이 범위 안으로 들어오게 되어 -1이 출력되는 것이다.


	/*
	자리값 :  8     7     6    5    4  3  2  1 
	숫자값: 128  64  32  16   8  4  2  1

	문제 1 : 01101001 -> 105
	문제 2 : 01011001 -> 89
	문제 3 : 00110100 -> 52
	*/
	return 0;
}